DartおよびFlutterによるServerpodバックエンドWebアプリケーションの包括的なディレクトリ構造


はじめに

このレポートでは、Dartをフルスタックで活用したモダンなWebアプリケーションに最適なディレクトリ構造を詳細に解説します。フロントエンドはFlutter（バージョン3.19以降）、バックエンドはServerpod（バージョン1.2以降）で構築され、どちらもDart言語を使用します。データ永続化にはPostgreSQL（バージョン14以降）、キャッシュおよびセッション管理にはRedis（バージョン7以降）が利用されます。開発環境はVisual Studio Codeを推奨し、PostgreSQLおよびRedisのコンテナ起動にはDockerが活用されます。
適切に定義されたディレクトリ構造は、本プロジェクトのようなフルスタックアプリケーションにおいて、その保守性、デバッグの容易さ、チームコラボレーション、および将来的なスケーラビリティを向上させる上で極めて重要です。確立されたパターンやフレームワークの慣例に従うことで、認知的負荷を最小限に抑え、開発を加速させることが可能になります。

全体的なモノレポプロジェクト構造

本プロジェクトの基盤は、Serverpodが本質的に持つモノレポ設計にあります。serverpod createコマンド（1）を使用して新しいServerpodプロジェクトを開始すると、自動的に3つの異なるDartパッケージを含む統合されたワークスペースがセットアップされます。この構造化されたアプローチは、Serverpod自身のコードベース（2）にも反映されており、クロスパッケージの依存関係を合理化し、アプリケーションスタック全体で型安全性を確保する中核的な設計思想です。
Serverpodのデフォルトモノレポ設定の説明:
Serverpodは、単一のトップレベルディレクトリ内に複数のDartパッケージを包含するモノレポ構造を強制します。これは、Serverpodフレームワークによる意図的な設計選択です（1）。この構造は、単なる推奨事項ではなく、Serverpodの根幹をなす設計原則であり、プロジェクトの初期段階から一貫した開発体験を提供します。
生成される主要なパッケージは以下の通りです。
<project_name>_server: すべてのバックエンドロジック、APIエンドポイント、およびデータベースモデルを含むサーバーサイドのパッケージです。
<project_name>_client: Serverpodによって自動生成される共有クライアントライブラリであり、フロントエンドがバックエンドと通信できるようにします。このパッケージは、サーバーサイドで定義されたデータモデルやAPIエンドポイントの型情報をフロントエンドに透過的に提供し、両者の間の契約を厳密に保ちます。
<project_name>_flutter: Serverpodバックエンドへの接続があらかじめ設定されたFlutter Webアプリケーション自体です。
このモノレポ設定は、依存関係管理を簡素化し、一貫したツール利用を保証し、フルスタック全体で統一された開発体験を促進します。これにより、異なる部分での作業が円滑に進み、統合時の問題が最小限に抑えられます。
表1: 高レベルモノレポディレクトリ概要
この表は、プロジェクト全体のトップレベルの構成を即座に明確に理解できるよう提供し、各主要パッケージとサポートファイルの明確な役割を示します。

ディレクトリ/ファイル
説明
<project_name>_server/
Serverpodバックエンドアプリケーションのソースコード、設定、およびデータベース関連ファイルを含む。
<project_name>_client/
Serverpodによって自動生成されるクライアントライブラリ。フロントエンドがバックエンドと通信するための型安全なAPIを提供する。手動で編集すべきではない。
<project_name>_flutter/
FlutterフロントエンドWebアプリケーションのソースコード、アセット、および設定ファイルを含む。
.vscode/
Visual Studio Codeのワークスペース設定、推奨拡張機能、およびデバッグ設定を格納する。
docker-compose.yaml
PostgreSQL、Redis、およびServerpodテストサーバーなどの開発環境サービスをDockerコンテナとして定義し、オーケストレーションするための設定ファイル。
README.md
プロジェクトの概要、目的、および基本的なセットアップ手順を提供する。
SETUP.md
Redisの導入方法など、特定のセットアップ手順や依存関係の詳細を記述する。
pubspec.yaml
モノレポ全体の開発ツールや共通の依存関係を定義する場合に存在しうる（Serverpodのデフォルト生成には含まれない場合もあるが、大規模プロジェクトでは検討される）。


フロントエンドアプリケーション構造 (<project_name>_flutter)

Flutterアプリケーションのコアはlib/ディレクトリにあります。このディレクトリの構造は、アプリケーションの複雑性が増すにつれて、その保守性とスケーラビリティに直接影響を与えます。Flutter公式ドキュメント（4）が推奨するような、明確な責務分離に基づくアーキテクチャパターンを採用することが極めて重要です。
推奨されるアーキテクチャパターン（例: MVVM、レイヤードアーキテクチャ）:
Flutterアプリケーションは、UI層とデータ層の2つの広範な層に分割されるべきです。複雑なロジックを持つアプリケーションでは、これら2つの層の間にロジック層（ドメイン層）を設けることも推奨されます（4）。このレイヤードアーキテクチャは、各コンポーネントの責務を明確にし、コードの再利用性、テスト容易性、および保守性を大幅に向上させます。
UI層: ユーザーとのインタラクションを担当します。アプリケーションのデータをユーザーに表示し、ユーザー入力（タップイベント、フォーム入力など）を受け取ります。UIはデータ変更やユーザー入力に反応して再描画されます（4）。
Views: アプリケーションデータをユーザーに提示する方法を記述します。これらは通常、特定の機能や画面を構成するウィジェットの集合体です。ユーザーインタラクションに応じてイベントをView Modelに渡す役割も担います（4）。
View Models: アプリケーションデータをUIの状態に変換するロジックを含みます。リポジトリからのデータは、表示に必要な形式とは異なる場合があるため、複数のリポジトリからのデータを結合したり、リストをフィルタリングしたりするロジックが含まれることがあります。View ModelはUIの状態を管理し、Viewはその状態を表示します（4）。
データ層: ビジネスデータとロジックを処理します。
Repositories: モデルデータの真のソースです。キャッシング、エラーハンドリング、リトライロジック、データのリフレッシュなど、サービスに関連するビジネスロジックを処理します（4）。Serverpodのクライアントは、このデータ層のサービスやリポジトリによって利用されることになります。
Services: 実際のデータフェッチングやデータストレージを担当します。
ドメイン層（オプション）: 複雑なロジックを持つアプリケーションの場合にUI層とデータ層の間に位置するロジック層です。
Use Cases (または Interactors): リポジトリに依存し、特定のビジネス操作を提供します。View Modelは1つ以上のUse Caseとリポジトリに依存する場合があります（4）。
lib/ディレクトリ内の主要なサブディレクトリの詳細な内訳:
ui/:
pages/: アプリケーションの各画面（ページ）を表すウィジェットを格納します。通常、Scaffoldウィジェットなど、画面全体のレイアウトを定義するトップレベルのウィジェットが含まれます（4）。
widgets/: アプリケーション全体で再利用される小さなUIコンポーネント（ウィジェット）を格納します。これらは特定の機能に特化せず、より汎用的なUI要素として設計されます（6）。
components/: 特定の機能やページに関連する再利用可能なUIコンポーネントを格納します（6）。
widgets/よりも特定の文脈を持つことが多いです。
view_models/:
アプリケーションのUI状態を管理し、ビジネスロジックをUIから分離するためのView Modelを格納します。使用する状態管理ソリューション（例: Provider, BLoC, Cubit, Riverpodなど）に応じて、対応するクラスやロジックが配置されます。
data/:
repositories/: アプリケーションのビジネスデータの真のソースとなるリポジトリインターフェースと実装を格納します。これらはデータソース（例: Serverpodクライアント、ローカルストレージ）からのデータを抽象化し、ビジネスロジック（キャッシング、エラー処理など）をカプセル化します（4）。
services/: 実際のデータ操作（API呼び出し、データベース操作など）を実行するサービスを格納します。Serverpodクライアントのインスタンス化と、それを通じたバックエンドとの直接的な通信は、通常この層のサービスで行われます（4）。
models/: アプリケーション内で使用されるデータ構造やエンティティのDartクラスを定義します。これらはServerpodのプロトコル定義から生成されるモデルとは別に、UI層やドメイン層で利用しやすいように変換されたモデルを定義する場合に利用されます。
domain/ (オプション):
use_cases/: 複雑なビジネスロジックや特定のユースケースをカプセル化するクラスを格納します。これらは1つ以上のリポジトリに依存し、View Modelにビジネス操作を提供します（4）。アプリケーションの規模が大きくなり、ビジネスロジックが複雑になる場合に導入を検討します。
auth/:
認証関連のロジック、サービス、およびUIコンポーネントを格納します。ユーザー認証状態の管理、ログイン/ログアウト処理、ユーザー情報の取得などが含まれます（6）。
backend/:
Serverpodクライアントとの統合に関連するカスタムロジックやユーティリティを格納します。Serverpodの生成コードを直接利用するのではなく、その上に抽象化レイヤーを構築する場合に有用です。api_requests/やschema/のようなサブディレクトリを持つこともあります（6）。
utils/:
アプリケーション全体で利用される汎用的なユーティリティ関数、ヘルパークラス、定数などを格納します。例としては、日付フォーマッター、バリデーションヘルパー、共通の拡張関数などが挙げられます。
generated/:
Serverpodによって自動生成されたクライアントサイドのコードが配置されます。これには、サーバーサイドのプロトコル定義（YAMLファイル）から生成されたデータモデルクラスや、エンドポイント呼び出しのためのクライアントメソッドが含まれます（3）。
このディレクトリ内のファイルは手動で編集すべきではありません。手動で変更すると、コード生成時に上書きされる可能性があります（3）。
assets/:
アプリケーションが使用する静的ファイル（画像、フォント、その他のリソース）を格納するディレクトリです（6）。これらのファイルはアセットパスを通じてコード内でアクセスされ、アプリケーションのビルド時にバンドルされます。
pubspec.yamlおよびその他の設定ファイル:
pubspec.yaml: Flutterアプリケーションの依存関係、メタデータ、アセットの宣言、およびその他の設定を定義します。
analysis_options.yaml: DartおよびFlutterの静的解析ルールを定義します。
l10n.yaml: 国際化（i18n）のための設定ファイルです。
表2: <project_name>_flutter/libサブディレクトリ詳細
この表は、Flutterアプリケーションの内部構造を、推奨されるアーキテクチャパターンと連携させて詳細に示します。

ディレクトリ/ファイル
責務
関連するアーキテクチャ層
lib/main.dart
アプリケーションのエントリーポイント、ルートウィジェットの定義。
UI層（エントリポイント）
lib/ui/
ユーザーインターフェース関連のコード。
UI層（Views）
lib/ui/pages/
各画面（ページ）のウィジェット。
UI層（Views）
lib/ui/widgets/
アプリケーション全体で再利用される汎用ウィジェット。
UI層（Views）
lib/ui/components/
特定の機能に関連する再利用可能なUIコンポーネント。
UI層（Views）
lib/view_models/
UIの状態管理と表示ロジック。
UI層（View Models）
lib/data/
データ取得、永続化、およびビジネスロジック。
データ層（Repositories, Services）
lib/data/repositories/
データソースからのデータを抽象化し、ビジネスロジックをカプセル化。
データ層（Repositories）
lib/data/services/
実際のデータ操作（API呼び出し、DB操作）。Serverpodクライアント利用。
データ層（Services）
lib/data/models/
UI層やドメイン層で利用するデータモデル。
データ層（Models）
lib/domain/
複雑なビジネスロジックやユースケース（オプション）。
ドメイン層（Use Cases）
lib/auth/
認証関連のロジックとUIコンポーネント。
UI層 / データ層（特定機能）
lib/backend/
Serverpodクライアントとのカスタム統合ロジック。
データ層（統合レイヤー）
lib/utils/
汎用的なユーティリティ関数やヘルパークラス。
共通ユーティリティ
lib/generated/
Serverpodによって自動生成されたクライアントコード。編集不可。
データ層（生成コード）


バックエンドサーバー構造 (<project_name>_server)

Serverpodバックエンドは、その設計の中心にコード生成を据えています。これにより、サーバーとクライアント間で型安全な通信が実現され、開発者はボイラープレートコードの記述から解放されます。
lib/src/:
このディレクトリは、Serverpodサーバーの主要なソースコードを格納します。
endpoints/:
APIエンドポイントの定義が配置されます（3）。Serverpodのコードジェネレーターは、これらのエンドポイント内のメソッドを解析し、対応するクライアントライブラリを生成します（7）。これにより、フロントエンドからバックエンドの機能に型安全な方法で直接アクセスできるようになります。各エンドポイントは、
Sessionオブジェクトを最初のパラメータとして持つメソッドを公開し、データベースアクセスやセッション情報へのアクセスを提供します（3）。
protocol/:
このディレクトリには、データモデルとデータベーステーブルのYAML定義ファイルが格納されます（3）。ServerpodはこれらのYAMLファイルから、サーバーとクライアントの両方で利用可能なシリアライズ可能なDartオブジェクトを生成します（3）。この
protocol/ディレクトリは、アプリケーションスタック全体におけるデータ構造の単一の真のソースとして機能します。これにより、フロントエンドとバックエンド間でデータ型の不一致によるランタイムエラーのリスクが大幅に低減され、開発プロセスが加速されます。
generated/:
Serverpodのコードジェネレーターによって生成されたサーバーサイドのコードが配置されます。これには、protocol/で定義されたモデルのDartクラスや、データベース操作のためのORM（Object-Relational Mapping）コードなどが含まれます（7）。
このディレクトリ内のファイルは自動生成されるため、手動で編集すべきではありません。
config/:
Serverpodサーバーの構成ファイルが格納されます。これには、開発、ステージング、および本番環境でサーバーを実行するための設定や、password.yamlのような機密情報を含むファイルが含まれます（3）。このディレクトリは、環境ごとに異なる設定を安全に管理し、柔軟なデプロイメントを可能にする上で不可欠です。
bin/:
ServerpodサーバーのエントリーポイントとなるDartスクリプト（通常はmain.dart）が配置されます（1）。サーバーの起動ロジックや、データベースマイグレーションの適用（
--apply-migrationsフラグを使用）などの初期化処理が記述されます（1）。
pubspec.yamlおよびその他の設定ファイル:
pubspec.yaml: Serverpodサーバーの依存関係、メタデータ、およびその他の設定を定義します。
analysis_options.yaml: Dartの静的解析ルールを定義します。
表3: <project_name>_server/lib/srcサブディレクトリ詳細
この表は、Serverpodバックエンドの主要なソースコード構造を、その役割とコード生成の側面を強調して示します。

ディレクトリ/ファイル
責務
コード生成との関連性
lib/src/endpoints/
クライアントから呼び出されるAPIエンドポイントの定義。
クライアントライブラリの自動生成元。
lib/src/protocol/
データモデルおよびデータベーステーブルのYAML定義。
サーバーおよびクライアントのデータモデルの自動生成元。
lib/src/generated/
Serverpodによって自動生成されたサーバーサイドのモデルおよびORMコード。
生成されたコードであり、手動編集は推奨されない。


共有クライアントパッケージ構造 (<project_name>_client)

<project_name>_clientパッケージは、FlutterアプリケーションとServerpodバックエンド間の通信を円滑にするためにServerpodによって自動生成される重要なコンポーネントです（3）。
目的と生成された性質の強調:
このパッケージは、サーバーサイドで定義されたエンドポイントとデータモデルに対応するDartクラスとメソッドを提供します。これにより、フロントエンド開発者は、バックエンドAPIとのインタラクションを型安全な方法で、かつボイラープレートコードを記述することなく行うことができます（1）。このパッケージのコードは、サーバーの
lib/src/protocol/およびlib/src/endpoints/ディレクトリの定義に基づいて、serverpod generateコマンドを実行するたびに自動的に生成されます（3）。
手動編集の非推奨:
<project_name>_clientパッケージ内のファイルは、Serverpodのコードジェネレーターによって完全に管理されています（3）。したがって、
これらのファイルを直接手動で編集することは強く推奨されません。手動での変更は、次回のコード生成時に上書きされ、作業が失われる可能性があります。フロントエンドからバックエンドへのインターフェースを変更する必要がある場合は、常にサーバーのlib/src/protocol/またはlib/src/endpoints/内のYAML定義やDartコードを変更し、その後コードを再生成する必要があります。
lib/src/generated/:
このディレクトリには、クライアントサイドのデータモデルクラス（サーバーのprotocol定義に対応）と、バックエンドのエンドポイントを呼び出すためのクライアントAPIが含まれます（3）。Flutterアプリケーションは、この生成されたクライアントを介してServerpodバックエンドと通信します。

ルートレベルのファイルとディレクトリ

モノレポのルートディレクトリには、プロジェクト全体を管理し、開発環境をセットアップするための重要なファイルとディレクトリが配置されます。
docker-compose.yaml:
このファイルは、PostgreSQLデータベースとRedisキャッシュ、そしてServerpodテストサーバーをDockerコンテナとして起動・管理するための設定を定義します（1）。Dockerは、これらの重要な依存関係の一貫したセットアップを保証し、環境固有のインストール複雑性を抽象化するため、ローカル開発環境の主要なオーケストレーションツールとして機能します（1）。これにより、新しい開発者のオンボーディングが迅速化され、開発環境間の均一性が確保されます。ユーザーの要件で言及されている
SETUP.mdファイルは、これらのDockerコマンドの詳細を記述することになります。
.vscode/:
Visual Studio Codeを使用する場合、このディレクトリにはワークスペース設定、推奨される拡張機能、およびデバッグ構成が含まれます。これにより、チームメンバー間で一貫した開発体験が提供され、生産性が向上します。
README.md, SETUP.md:
README.md: プロジェクトの目的、主要な機能、およびコードベースの概要を説明する包括的なドキュメントです。
SETUP.md: ユーザーの要件で明示的に言及されているように、PostgreSQLやRedisのセットアップ方法、Serverpodサーバーの起動手順など、プロジェクトをローカルで実行するための詳細なステップバイステップガイドを提供します。
pubspec.yaml:
Serverpodのデフォルト生成には含まれない場合がありますが、モノレポ全体で共有される開発依存関係やツール（例: Linterの設定、コードフォーマッター）を管理するために、ルートレベルにpubspec.yamlを配置する場合があります。これは、複数のパッケージにわたる依存関係の一貫性を維持するのに役立ちます。

主要なアーキテクチャ上の考慮事項とベストプラクティス

このDartおよびFlutterとServerpodを用いたWebアプリケーションの構造は、単なるファイルの配置以上の意味を持ちます。それは、アプリケーションの長期的な健全性と開発効率を保証するための、いくつかの重要なアーキテクチャ原則を反映しています。
責務の分離の重要性:
UI層、データ層、そしてオプションのドメイン層という明確なレイヤーへの分割は、各コンポーネントが単一の明確な責務を持つことを保証します（4）。FlutterアプリケーションにおけるMVVMパターンと、Serverpodのサーバーおよびクライアントパッケージの分離は、この原則を強力に推進します。これにより、コードの変更が他の部分に与える影響が最小限に抑えられ、異なるチームメンバーが独立して作業を進めることが可能になります。また、各層が独立しているため、ユニットテストや統合テストの記述が大幅に簡素化され、アプリケーション全体の品質向上に寄与します。
Serverpodのコード生成の活用:
Serverpodのコード生成機能は、本プロジェクトの効率性と型安全性の中心です。サーバーのprotocol/ディレクトリで定義されたYAMLスキーマは、バックエンドのデータモデルとAPIコントラクトの単一の真のソースとして機能します（3）。この中央集権的な定義から、サーバーとクライアントの両方のDartコードが自動的に生成されることで、手動でのボイラープレートコードの記述が不要になり、開発時間が短縮されます。さらに重要なのは、フロントエンドとバックエンド間でデータ型が厳密に一致することが保証され、API統合における一般的なエラーが排除されることです。これにより、開発者はビジネスロジックの構築に集中でき、データ同期の煩雑さから解放されます。
スケーラビリティとモジュール性に関する考慮事項:
Serverpodが強制するモノレポ構造と、Flutterアプリケーション内のレイヤードアーキテクチャは、アプリケーションの将来的な成長と進化をサポートするように設計されています。新しい機能を追加する際、それらを既存の構造にシームレスに統合することが容易になります。例えば、Serverpodモジュール（2）の概念は、認証やチャットのような特定の機能を独立したパッケージとして開発し、必要に応じてプロジェクトに組み込むことを可能にします。同様に、Flutterアプリケーション内で機能ごとにディレクトリを分割し、各機能が独自のUI、View Model、およびデータ層のコンポーネントを持つようにすることで、大規模なアプリケーションでも管理しやすくなります。
テストへの影響:
明確に分離された層を持つ構造は、テスト戦略を大きく簡素化します。UI層のView ModelはFlutterウィジェットから独立してテストでき、ビジネスロジックの検証が容易になります（4）。データ層のリポジトリとサービスは、実際のバックエンドやデータベースに依存することなく、モックされたデータソースを使用してテストできます。Serverpod自体も広範なテストフレームワーク（2）を備えており、エンドポイントやデータベース操作のテストをサポートします。このテスト容易性は、アプリケーションの品質を保証し、リファクタリングや機能追加の際の自信を高める上で不可欠です。

結論

DartとFlutterをServerpodバックエンドと組み合わせたWebアプリケーションの構築において、適切に計画されたディレクトリ構造は、単なる組織化の手段を超えた、戦略的な資産となります。Serverpodが提供するモノレポの枠組みは、フロントエンドとバックエンド間のシームレスな統合と型安全な通信を保証し、開発の複雑性を大幅に軽減します。
本レポートで詳述した構造は、Flutterの公式ガイドラインが推奨するUI層、データ層、およびオプションのドメイン層からなるレイヤードアーキテクチャと、Serverpodのコード生成機能を最大限に活用するように設計されています。lib/src/protocol/における単一のデータモデル定義から、サーバーとクライアントの両方にコードが生成されるプロセスは、開発効率を高め、エラーを削減する上で極めて重要です。また、Dockerの活用は、依存関係の一貫した管理と開発環境の迅速なセットアップを可能にし、チームの生産性を向上させます。
この構造を採用することで、プロジェクトは高い保守性、テスト容易性、およびスケーラビリティを確保できます。将来の機能拡張やチームの拡大にも柔軟に対応できる強固な基盤が提供され、Dartをフルスタックで活用するメリットを最大限に引き出すことが可能になります。プロジェクトの健全性を維持するためには、これらの構造原則を遵守し、コードレビューを通じて一貫性を保つことが継続的に推奨されます。
Works cited
Installation | Serverpod, accessed July 2, 2025, https://docs.serverpod.dev/
Roadmap & contributions - Installation | Serverpod, accessed July 2, 2025, https://docs.serverpod.dev/2.2.0/contribute
Get started - Installation | Serverpod, accessed July 2, 2025, https://docs.serverpod.dev/1.1.1/get-started
Guide to app architecture - Flutter Documentation, accessed July 2, 2025, https://docs.flutter.dev/app-architecture/guide
Layout | Flutter, accessed July 2, 2025, https://docs.flutter.dev/ui/layout
Directory Structure | FlutterFlow Documentation, accessed July 2, 2025, https://docs.flutterflow.io/generated-code/project-structure/
Build your first app - Installation | Serverpod, accessed July 2, 2025, https://docs.serverpod.dev/tutorials/first-app
